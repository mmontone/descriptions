{"name":"{} descriptions","tagline":"Meta level descriptions library for Common Lisp","body":"{} descriptions\r\n========\r\n\r\nOverview\r\n--------\r\n\r\n**{} descriptions** is a meta level descriptions library for Common Lisp.\r\n\r\nIt is inspired by [Smalltalk Maggrite](http://code.google.com/p/magritte-metamodel/), as well as [Lisp On Lines](http://www.cliki.net/lisp-on-lines).\r\n\r\nInstall\r\n-------\r\n\r\nDownload the source code from https://github.com/mmontone/descriptions and point `.asd` system definition files from `./sbcl/system (ln -s <system definition file path>)` and then evaluate:\r\n\r\n```lisp\r\n(require :descriptions)\r\n```\r\n\r\nfrom your lisp listener. \r\n\r\nYou will also need to satisfy these system dependencies:\r\n\r\n- `alexandria`\r\n- `anaphora`\r\n- `sheeple`\r\n- `cxml` and `cl-json` for the serialization module\r\n- `cl-ppcre` for the validation module\r\n\r\nThe easiest way of installing those packages is via [Quicklisp](http://www.quicklisp.org/).\r\n\r\nThis library is under the MIT licence.\r\n\r\nGetting started\r\n---------------\r\n\r\n**{} descriptions** is a very dynamic meta-description library similar to [Smalltalk Maggrite](http://code.google.com/p/magritte-metamodel/) and [Lisp On Lines](http://www.cliki.net/lisp-on-lines). Meta description of the application's domain model is done defining descriptions for the different aspects is desired to represent. This helps automate the generation of different views, editors, serialization schemas, validation procedures for the domain model objects and to avoid very repetitive and error-prone work when those objects change its shape.\r\n\r\nDomain model meta descriptions consist of the definition of description objects for its different aspects (viewing, editing, validation, persistence, serialization, etc). Description objects are a collections of attributes, can inherit from each other, and are composable.\r\n\r\nLet's go through an example to see how this works.\r\n\r\nSay we have a _person_ model object:\r\n\r\n```lisp\r\n(defclass person ()\r\n  ((id :accessor id)\r\n   (username :initarg :username\r\n\t     :accessor username)\r\n   (fullname :initarg :fullname\r\n             :accessor fullname)\r\n   (email :initarg :email\r\n          :accessor email)\r\n   (password :initarg :password\r\n\t     :accessor password)))\r\n```\r\n\r\nWe would like to print instances of that model on the screen. So first we define a *{person}* description that just describes which attributes _person_ model objecs possess and their \"types\".\r\n\r\n```lisp\r\n(define-description {person} ()\r\n  ((username =>string\r\n\t     :reader #'username\r\n\t     :writer #'(setf username))\r\n   (email =>email\r\n\t  :reader #'email\r\n\t  :writer #'(setf email))\r\n   (fullname =>string\r\n\t     :reader #'fullname\r\n\t     :writer #'(setf fullname))\r\n   (password =>password\r\n\t     :reader #'password\r\n\t     :writer #'(setf password)))\r\n  :documentation \"A person description\")\r\n```\r\nDescriptions names are enclosed between brackets `{` `}` as a naming convention. Also, notice that the attribute types (`=>string`, `=>email`, `=>password`), begin with `=>`. Attributes types begin with `=>` as a naming convention.\r\n\r\nNow we can use the information on the attributes of a person, and its types, to print a description of a person on the screen. To do that we define a new description that indicates which person slots we would like to print, and in which order.\r\n\r\n```lisp\r\n(define-description {person-view} ({person})\r\n  ((fullname =>view :label \"Full name\")\r\n   (username =>view)\r\n   (email =>view :label \"E-mail\")\r\n   (password =>view :view nil)))\r\n```\r\n\r\nWe can see that the password is disabled for viewing, that \"Full name\" and \"E-mail\" are used for labels, and that fullname, username, email and password are to be displayed in that order.\r\n\r\nWe can see that in action:\r\n```lisp\r\n(display-object (make-instance 'person :username \"mmontone\"\r\n\t\t\t       :email \"mariano@copyleft.no\"\r\n\t\t\t       :password \"lalala\"\r\n\t\t\t       :fullname \"Mariano Montone\")\r\n\t\t{person-view})\r\n```\r\n\r\nprints:\r\n\r\n```\r\nFull name: \"Mariano Montone\"\r\nUsername: \"mmontone\"\r\nE-mail: \"mariano@copyleft.no\"\r\n\r\n```\r\n\r\n### Descriptions composition\r\n\r\nDescriptions can be composed using inheritance. Multiple inheritance is supported and they are implemented on top of a prototype based object system, so they can be composed in run time on the fly.\r\n\r\n#### Attributes composition\r\n\r\nWhen inheriting from other descriptions, attributes with the same name are collapsed into one containing all the attribute properties.\r\n\r\nFor example, consider the basic *{person}* description we had before. We can ask for an attribute name and type, but asking if that attribute is going to be displayed throws an error, because that attribute property does not belong to the {person} description, but the *{person-view}* description we saw before.\r\n\r\n```lisp\r\n{}> (attribute-name (get-attribute {person} 'fullname))\r\nFULLNAME\r\n{}> (attribute-type (get-attribute {person} 'fullname))\r\n#<Object =>STRING {1005A0A0A3}>\r\n{}> (attribute-view (get-attribute {person} 'fullname))\r\n;; Error\r\n```\r\n\r\nBut if we ask the same to the *{person-view}* description, we can access to all the attributes properties.\r\n```lisp\r\n{}> (attribute-name (get-attribute {person-view} 'fullname))\r\nFULLNAME\r\n{}> (attribute-type (get-attribute {person-view} 'fullname))\r\n#<Object =>STRING {1005A0A0A3}>\r\n{}> (attribute-view (get-attribute {person-view} 'fullname))\r\nT\r\n```\r\n\r\nThis makes the approach layered, with each description describing different aspects of the same model and extending other more basic descriptions.\r\n\r\n#### Descriptions composition\r\n\r\nAs we mentioned before, descriptions can be composed on the fly thanks to the prototype object system the library is implemented in.\r\n\r\nFor example, we can create new descriptions with the *make-description* function, passing the descriptions we want to compose as parents:\r\n\r\n```lisp\r\n(let ((description (make-description :parents\r\n\t\t\t\t     (list {person-validation} {person-repl-editing}))))\r\n  (let ((person (make-instance 'person)))\r\n      (edit-object person description)\r\n      (validate-object person description)\r\n      (describe person)))\r\n```\r\n\r\nA prettier way of doing it is using the description name as a function:\r\n\r\n```lisp\r\n(let ((description ({person-validation} {person-repl-editing})))\r\n    (let ((person (make-instance 'person)))\r\n      (edit-object person description)\r\n      (validate-object person description)\r\n      (describe person)))\r\n```\r\n\r\nWe can also choose not to compose descriptions, but work with them separately on the different aspects of the model objects:\r\n```lisp\r\n(let ((person (make-instance 'person)))\r\n  (edit-object person {person-repl-editing})\r\n  (validate-object person {person-validation})\r\n  (describe person)\r\n  (print\r\n   (with-output-to-string (s)\r\n     (serialize-object person {person-serialization} s))))\r\n\r\n```\r\nImplementation\r\n--------------\r\n\r\n**{} descriptions** is implemented as a thin layer over [Sheeple](http://www.cliki.net/sheeple) prototypes. As a consequence, descriptions and its attributes can be easily be combined in run time.\r\n\r\n### Why not just use metaclasses instead?\r\n\r\nIt is not possible to achieve quite the same with metaclasses. They do not allow to keep the metamodel independent of the actual implementation of the class. It should be possible to exchange descriptions on the fly, and even use multiple descriptions at the same time for the same underlying domain object.\r\n\r\nMetaclasses have their own specific power though, and may be good to use them in combination with descriptions.\r\n\r\nReferences\r\n----------\r\n\r\n* http://code.google.com/p/magritte-metamodel/\r\n* http://www.cliki.net/lisp-on-lines\r\n* http://common-lisp.net/project/lisp-on-lines/repo/lisp-on-lines/doc/manual.html\r\n* http://scg.unibe.ch/archive/papers/Reng07aMagritte.pdf\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}